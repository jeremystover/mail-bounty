'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ripple_address_codec_1 = __importDefault(require("ripple-address-codec"));
function toHex(bytes) {
    return Buffer.from(bytes).toString('hex').toUpperCase();
}
exports.toHex = toHex;
function toBytes(hex) {
    return new Uint32Array(Buffer.from(hex, 'hex').toJSON().data);
}
exports.toBytes = toBytes;
function uInt32_ToUInt32LE(integer) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(integer, 0);
    return buf.toString('hex').toUpperCase();
}
exports.uInt32_ToUInt32LE = uInt32_ToUInt32LE;
function uInt32LE_ToUInt32(hex) {
    return Buffer.from(hex, 'hex').readUInt32LE(0);
}
exports.uInt32LE_ToUInt32 = uInt32LE_ToUInt32;
function findPrefix(desiredPrefix, payloadLength) {
    // Thanks @sublimator
    var rippleCodec = ripple_address_codec_1.default.codecs.ripple;
    if (rippleCodec.base !== 58) {
        throw new Error('Only works for base58');
    }
    var factor = Math.log(256) / Math.log(rippleCodec.base);
    var totalLength = payloadLength + 4; // for checksum
    var chars = totalLength * factor;
    var requiredChars = Math.ceil(chars + 0.2);
    var alphabetPosition = Math.floor((rippleCodec.alphabet.length) / 2) - 1;
    var padding = rippleCodec.alphabet[alphabetPosition];
    var rcPad = new Array(requiredChars + 1).join(padding);
    var template = desiredPrefix + rcPad;
    var bytes = rippleCodec.decodeRaw(template);
    var version = bytes.slice(0, -totalLength);
    return version;
}
exports.findPrefix = findPrefix;
